#+TITLE: hibp-verifier
#+OPTIONS: toc:2

[[https://github.com/PrismaPhonic/hibp-rs/actions][https://img.shields.io/github/actions/workflow/status/PrismaPhonic/hibp-rs/ci.yml?branch=main]]
[[https://img.shields.io/badge/maintenance-actively--developed-brightgreen]]

A high-performance library for checking passwords against the Have I Been Pwned
breach database. Uses stack buffer read files and binary search for
sub-microsecond lookups.

* Features

- Zero-allocation hot path for password checking (sync API)
- O(log n) binary search on sorted sha1t48 records
- sub microseconds lookups
- Optional async API with tokio or compio support

* Installation

Add to your =Cargo.toml=:

#+begin_src toml
[dependencies]
hibp-verifier = { git = "https://github.com/PrismaPhonic/hibp-rs" }
#+end_src

* Usage

#+begin_src rust
use hibp_verifier::BreachChecker;
use std::path::Path;

let checker = BreachChecker::new(Path::new("/path/to/hibp-data"));

match checker.is_breached("password123") {
    Ok(true) => println!("Password found in breach database"),
    Ok(false) => println!("Password not found"),
    Err(e) => eprintln!("Error: {}", e),
}
#+end_src

* Async Usage

Enable the =tokio= feature for async support:

#+begin_src toml
[dependencies]
hibp-verifier = { git = "https://github.com/PrismaPhonic/hibp-rs", features = ["tokio"] }
#+end_src

The async API performs SHA1 hashing and path construction on the async thread,
then uses =spawn_blocking= only for file I/O. This is faster than
=tokio::fs::File= because it uses a single blocking call instead of multiple
calls per I/O operation.

** Example

#+begin_src rust
use hibp_verifier::BreachChecker;
use std::path::Path;

#[tokio::main]
async fn main() -> std::io::Result<()> {
    let checker = BreachChecker::new(Path::new("/path/to/hibp-data"));

    if checker.is_breached_async("password123").await? {
        println!("Password found in breach database!");
    }

    Ok(())
}
#+end_src

* Compio Usage (io-uring)

Enable the =compio= feature for native io-uring async support:

#+begin_src toml
[dependencies]
hibp-verifier = { git = "https://github.com/PrismaPhonic/hibp-rs", features = ["compio"] }
#+end_src

This uses compio's native io-uring file I/O with a multi-threaded dispatcher.
Note that benchmarks show this is ~1.5x slower than the tokio =spawn_blocking=
approach. See the Performance section for details.

** Example

#+begin_src rust
use hibp_verifier::BreachChecker;
use std::path::Path;

fn main() -> std::io::Result<()> {
    let checker = BreachChecker::new(Path::new("/path/to/hibp-data"));

    compio::runtime::Runtime::new()?.block_on(async {
        if checker.is_breached_compio("password123").await? {
            println!("Password found in breach database!");
        }
        Ok(())
    })
}
#+end_src

** Web Framework Integration

Compio is compatible with ntex's compio runtime feature, making =is_breached_compio=
suitable for use within ntex web applications.

* Dataset Setup

The verifier requires a pre-downloaded dataset in sha1t48 binary format. Use
[[../hibp-downloader][hibp-downloader]] to fetch and convert the data:

#+begin_src sh
hibp-downloader --output /path/to/hibp-data
#+end_src

** Specifying the Dataset Location

Set the =HIBP_DATA_DIR= environment variable to point to your dataset:

#+begin_src sh
export HIBP_DATA_DIR=/path/to/hibp-data
#+end_src

If unset, tests and benchmarks fall back to =pwnedpasswords-bin= in the
workspace root (sibling to the =hibp-verifier= directory).

** Running Tests

Unit tests that do not require the dataset run by default:

#+begin_src sh
cargo test -p hibp-verifier
#+end_src

To run tests that require the dataset, use the =--ignored= flag:

#+begin_src sh
HIBP_DATA_DIR=/path/to/hibp-data cargo test -p hibp-verifier -- --ignored
#+end_src

To run all tests (both regular and ignored):

#+begin_src sh
HIBP_DATA_DIR=/path/to/hibp-data cargo test -p hibp-verifier -- --include-ignored
#+end_src

** Running Benchmarks

Sync benchmarks:

#+begin_src sh
HIBP_DATA_DIR=/path/to/hibp-data cargo bench -p hibp-verifier
#+end_src

Async benchmarks:

#+begin_src sh
HIBP_DATA_DIR=/path/to/hibp-data cargo bench -p hibp-verifier --features tokio
#+end_src

* Binary Format

The library expects a directory containing 1,048,576 files named =00000.bin=
through =FFFFF.bin=. Each file contains sorted 6-byte sha1t48 records for the
corresponding SHA1 prefix (skipping first 2 bytes, as it's redundantly in the
2.5 byte prefix of the file name).

** Record Layout

Each record is bytes 2 to 8 of a SHA1 hash (truncated to 48 bits). Records are
stored in ascending sorted order, enabling binary search.

** Collision Probability

With ~900 million entries, the probability of a false positive (collision) is
approximately 1 in 10 billion. For breach checking, false positives are harmless
since they only cause rejection of a password that could reasonably be avoided.

* Performance

** Sync API (Zero-Allocation)

Benchmark results on a modern CPU with data in page cache:

| Benchmark            | Time per batch | Time per password |
|----------------------+----------------+-------------------|
| common_passwords_20  | ~27.9 us       | ~1.39 us          |
| random_passwords_20  | ~28.2 us       | ~1.41 us          |
| mixed_passwords_40   | ~55.3 us       | ~1.38 us          |

The bottleneck is =File::open= and file read overhead. The actual binary
search completes in nanoseconds.

** Async API

High concurrency comparison (10k concurrent lookups, 24 worker threads):

| Method             | Time    | Per password | Notes                       |
|--------------------+---------+--------------+-----------------------------|
| =is_breached_async=  | ~31 ms  | ~3.1 us      | *Winner* - tokio thread pool  |
| =is_breached_compio= | ~46 ms  | ~4.6 us      | 1.5x slower - compio        |
| tokio::fs          | ~58 ms  | ~5.8 us      | 2x slower - not exposed     |
| std::thread::scope | ~192 ms | ~19.2 us     | 6x slower - thread overhead |

*** Method Explanations

**** =is_breached_async= (Recommended)

Uses =tokio::task::spawn_blocking= to run the entire sync file I/O operation
on tokio's blocking thread pool. This is the best choice for most applications
because:

1. Thread pool threads are pre-spawned and reused
2. Work-stealing distributes load across all pool threads
3. Single syscall batch (open + read + close) per operation
4. Compatible with tokio-based web frameworks (actix-web, axum)

**** =is_breached_compio= (io-uring alternative)

Uses compio's native io-uring file I/O with a multi-threaded dispatcher.
This is useful when you're already using compio (e.g., with ntex's compio
runtime) and want to avoid mixing runtimes.

Despite using io-uring, this is ~1.5x slower than tokio's spawn_blocking.
Investigation revealed the overhead is in compio's io-uring driver:

1. *Extra atomic operations*: Compio calls =squeue.sync()= after every operation
2. *Arc vs Rc*: Compio uses =Arc= for cross-thread safety even in single-threaded paths
3. *Cross-thread infrastructure*: Maintains eventfd and waking infrastructure

**** tokio::fs (benchmarked but not exposed)

Uses =tokio::fs::File= for "native" async file access. This is *not exposed*
in the library API because it performs worse than =is_breached_async=.

Tokio's async filesystem API internally wraps *every individual operation*
in a separate =spawn_blocking= call:

- =File::open()= → spawn_blocking
- =file.read()= → spawn_blocking (per call)

The overhead of multiple spawn_blocking round-trips makes this slower than
doing a single spawn_blocking for the entire operation.

*** Why spawn_blocking Wins

The key insight is that =spawn_blocking= distributes work across tokio's
blocking thread pool (default: 512 threads). Each file I/O operation runs in
parallel on a real OS thread, but thread creation/destruction overhead is
amortized because:

1. *Thread reuse*: Pool threads persist and handle many operations
2. *Work stealing*: Idle threads pull work from busy threads' queues
3. *Bounded concurrency*: The pool size prevents thread explosion

In contrast, =std::thread::scope= creates 10k OS threads simultaneously,
overwhelming the scheduler with context switches and memory allocation for
thread stacks.

* Design

** Zero-Allocation Path Building

The library constructs file paths without heap allocation by writing directly
into a 512-byte stack buffer:

#+begin_src rust
let mut path_buf = [0u8; 512];
// ... copy base path, separator, prefix hex, and ".bin" suffix
#+end_src

** Binary Search

Each prefix file is read into a stack allocated buffer.
Binary search uses direct indexing since records are fixed-size:

#+begin_src rust
let offset = mid * RECORD_SIZE;  // RECORD_SIZE = 6
let record = &data[offset..offset + RECORD_SIZE];
#+end_src

* Profiling

A profiling binary is included for detailed timing breakdown:

#+begin_src sh
HIBP_DATA_DIR=/path/to/hibp-data cargo run --release --bin profile
#+end_src

This shows cycle counts for each step: SHA1 hashing, prefix extraction, file
open, file read, and binary search.

* License

MIT
